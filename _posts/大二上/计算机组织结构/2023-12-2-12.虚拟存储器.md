---
title: 12. 虚拟存储器
categories: [大二上,计算机组织结构]
tag: [课内笔记,大二上,计算机组织结构] 
math: true
---

## 1. 内存管理

1. 早期计算机的主存中仅包含系统软件和一个用户程序
2. 现在计算机的主存中包含操作系统和若干个用户程序
   1. 当所有任务都需要等待I/O时，为了避免处理器处于空闲状态，需要尽可能让更多的任务进入主存
   2. 多道程序设计：让处理器一次处理多个任务，提高处理器的利用率
3. 内存管理
   1. 在多道程序系统中，主存需要进一步划分给多个任务，划分的任务由操作系统动态执行
   2. 本门课不区分“进程”和“任务”这个更抽象的概念

## 2. 如何将更多更大的任务装入主存

1. 增大主存容量
2. 使用交换（exchange）技术
   1. 当主存中没有处于就绪的任务时，操作系统调入其他任务来执行
   2. 分区（partitioning）和分页（paging）
3. 虚拟存储器
   1. **请求分页**：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上
   2. **虚拟地址**

## 3. 分区(Partitioning)

分区方式将主存分为两大区域

1. 系统区：**固定**的地址范围内，存放操作系统
2. 用户区：存放所有用户程序

### 3.1 简单固定分区

![image-20231202194648432](https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202194648432.png)

1. 用户区划分成长度不等的固定长的分区
2. 当一个任务调入主存时，分配一个**可用的、能容纳它的、最小的**分区（**如何分配分区很重要**）
3. 优点：简单
4. 缺点：浪费主存空间

### 3.2 可变长分区

<img src="https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202194937357.png" alt="image-20231202194937357" style="zoom: 80%;" />

1. 用户区按每个任务所需要的内存大小进行分配
2. 优点：提高了主存的利用
3. 缺点：时间越长，存储器中的**碎片**就会越多

## 4. 分页(Paging)

![image-20231202195312285](https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202195312285.png)

1. 目的：减少碎片的产生
2. 基本思想
   1. 把主存分成固定长且比较小的**存储块**，称为**页框（page frame）**，每个任务也被划分成固定长的**程序块**，称为**页（page）**
   2. 将页装入页框中，且**无需采用连续的页框**来存放一个任务中所有的页
3. 逻辑地址：指令中的地址
4. 物理地址：实际主存地址
5. 程序叫做**页**，放程序的地点叫做**页框**
   + 页放在哪里由OS决定，**在我们的程序中写的是逻辑地址，由操作系统的决定物理地址。**
   + 页放进去并不是连续的放入，页表记录页存在的位置
6. 分页:将内存分成固定大小的页框，将需要存储成页，寻找空的页框放入(空的即可，因为一样大)，这样做会导致程序的不连续性，但是**有页表来记录地址**。

## 5. 虚拟内存（Virtual Memory）

1. 基本思想
   1. **请求分页**：仅将当前**需要的的页**调入主存
      1. 通过硬件将逻辑地址转换为物理地址
      2. 未命中时（需要的页不在主存中）在主存和硬盘之间交换信息
2. 优点：
   1. 在不扩大物理内存的前提下，可以载入更多的任务
   2. 编写程序时不需要考虑可用物理内存的状态
      1. 程序员认为可以独享一个连续的、很大的内存
   3. 可以在大于物理内存的逻辑地址空间中编程

<img src="https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202195947331.png" alt="image-20231202195947331" style="zoom: 67%;" />

1. 先把程序加载到硬盘的特定区域，然后我们什么时候需要这个内存，我们移动到memory中去。
2. 存储是否被加载到物理内存中，如果被加载进入物理内存，则是物理地址。如果没有在里面则在Disk中
   1. 如果已经满了，我们就使用替换策略进行替换。
3. 内存中有的，Disk中也有的，因为是**拷贝**关系

### 5.1 设计问题

1. 页大小
   1. 4KB, 8KB, …
2. 映射算法
3. 写策略
4. 类型
   1. 分页式虚拟存储器
   2. 分段式虚拟存储器
   3. 段页式虚拟存储器

#### 5.1.1 分页式虚拟存储器

<img src="https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202201058942.png" alt="image-20231202201058942" style="zoom: 67%;" />

1. 主存储器和虚拟地址空间都被划分为大小相等的页面

   1. 虚拟页（virtual page，VP）/ 逻辑页（logical page）：虚拟地址空间中的页面
   2. 物理页（physical page，PP）/ 页框（page frame）：主存空间中的页面

2.  页表

   1. 页表中包含了所有虚拟页的信息，包括虚拟页的存放位置、装入位（valid）、 修改位（dirty）、存取权限位等等

   2. 保存在主存中

   3. 虚拟地址 = 虚拟页号 + 页内偏移量

      1. 根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址

         ![image-20231202201150926](https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202201150926.png)

   4. 每一个条目(虚拟页中):位置信息(物理页号、指向硬盘指针、null表示还没有被使用)、脏位(减少对磁盘的访问)、**有效位(有无被加载到物理内存中)**、读写权限

      <img src="https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202201203081.png" alt="image-20231202201203081" style="zoom:67%;" />

      1. 如果虚页已经载入到了物理内存中，我们就要记录它的物理地址(location,valid(使用位) = 1)
      2. location上用红字写的指针，的存储的是指向硬盘(虚拟内存中)的指针
      3. **location == null:表示磁盘里面没有,而不是内存中没有**
      4. 虚拟页号比物理页号要大一些，虚拟页号没必要存储，按照相应的物理页号位置来找虚拟页号的位置

   5. 如果location的长度是不同的(null，物理页号，指针)，那么我们必须按照最长的部分来等长存储

   6. 可以把页表放置到Cache中(但是是放置比较常用的页表的行)
   

#### 5.1.2 快表（Translation Lookaside Buffer， TLB）

页表在主存中，每次访问主存都需要查页表 Cache不就失效了吗？

1. 为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存（TLB中有的页，则**一定会在主存**里有）
2. 后备转换缓冲器（简称“快表”）：将页表项放入高速缓存中
   1. 映射：关联映射，组关联映射
   2. 替换：随机替换
3. 主存中的页表相应地称之为“慢表”

<img src="https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202201941908.png" alt="image-20231202201941908" style="zoom:67%;" />

4. CPU访存过程（看上去很复杂，其实随便看看就能理解了）

![image-20231202202115160](https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202202115160.png)

VA：虚拟地址

PA：物理地址

有需要将虚拟页号(VA)根据页表(Page table)转换到物理页号(PA)中去

![image-20231202202329818](https://salieri-typora.oss-cn-shanghai.aliyuncs.com/img/markdown/image-20231202202329818.png)

1. cache是内存的拷贝
2. **TLB miss的情况下只是比hit的情况多一次内存访问**
3. **TLB、页表valid表示在内存中**

#### 5.1.3 分段式虚拟存储器

1. 将程序和数据分成**不同长度的段**，将所需的段加载到主存中
2. 虚拟地址：段号 + 段内偏移量
3. 与分页式虚拟存储器相比
   1. 分页式虚拟存储器（页对程序员不可见）
      1. 优点：实现简单、开销少
      2. 缺点：一个数据或一条指令可能会分跨在两个页面
   2. 分段式虚拟存储器（段对程序员可见）
      1. 优点：段的分界与程序的自然分界相对应，易于编译、管理、修改和保护
      2. 缺点：段的长度不固定（引起碎片）

#### 5.1.4 段页式虚拟存储器

1. 将程序和数据分段，段内再进行分页，每个分段都有一个页表
2. 虚拟地址 = 段号 + 页号 + 页内偏移量
3. 优点：程序按段实现共享与保护
4. 缺点：需要多次查表
